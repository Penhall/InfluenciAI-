# MVP "Single Network Publisher" - Plano Técnico Detalhado

**Data:** 05/11/2025
**Objetivo:** Implementar o primeiro fluxo end-to-end de valor de negócio com Twitter/X
**Estimativa:** 4-6 semanas (Sprints 1-6)

---

## Visão Geral

Este MVP demonstra o core value do InfluenciAI:
1. **Conectar** uma conta de rede social (Twitter/X)
2. **Publicar** conteúdo
3. **Coletar** métricas
4. **Visualizar** resultados em tempo real

## Arquitetura do MVP

```
Desktop (WPF)
  ├── SocialConnectionView (conectar Twitter)
  ├── ContentEditorView (criar post)
  └── MetricsView (ver métricas)
       ↓
API Gateway
  ├── POST /api/social-profiles (OAuth callback)
  ├── GET /api/social-profiles (listar conexões)
  ├── POST /api/content (criar post)
  ├── POST /api/content/{id}/publish
  └── GET /api/content/{id}/metrics
       ↓
Application Layer
  ├── SocialProfiles Module (CQRS)
  ├── Content Module (CQRS)
  └── Analytics Module (CQRS)
       ↓
Domain Layer
  ├── SocialProfile (aggregate)
  ├── Content (aggregate)
  └── MetricSnapshot (aggregate)
       ↓
Infrastructure
  ├── Twitter.Integration (Tweetinvi)
  ├── DataCollectorService (background)
  └── PostgreSQL + Redis
```

---

## Sprint 1-2: Twitter Integration (2 semanas)

### Objetivos
- Conectar conta do Twitter/X via OAuth 2.0
- Publicar tweet simples (texto, máx 280 chars)
- Desktop: Views para conectar e publicar

### 1.1 Domain Layer - Novas Entidades

**SocialProfile.cs**
```csharp
namespace InfluenciAI.Domain.Entities;

public class SocialProfile : BaseEntity
{
    public Guid TenantId { get; set; }
    public Guid UserId { get; set; }
    public SocialNetwork Network { get; set; } // enum: Twitter, Instagram, etc
    public string ProfileId { get; set; } // ID externo na rede
    public string Username { get; set; }
    public string DisplayName { get; set; }
    public string ProfileImageUrl { get; set; }
    public string AccessToken { get; set; } // encrypted
    public string RefreshToken { get; set; } // encrypted
    public DateTime TokenExpiresAt { get; set; }
    public bool IsActive { get; set; }
    public DateTime ConnectedAt { get; set; }

    // Relacionamentos
    public Tenant Tenant { get; set; }
    public AppUser User { get; set; }
    public ICollection<Content> Contents { get; set; }
}

public enum SocialNetwork
{
    Twitter = 1,
    Instagram = 2,
    LinkedIn = 3,
    TikTok = 4,
    YouTube = 5
}
```

**Content.cs**
```csharp
namespace InfluenciAI.Domain.Entities;

public class Content : BaseEntity
{
    public Guid TenantId { get; set; }
    public Guid UserId { get; set; }
    public string Title { get; set; }
    public string Body { get; set; } // texto do post
    public ContentType Type { get; set; } // Text, Image, Video, etc
    public ContentStatus Status { get; set; } // Draft, Scheduled, Published, Failed
    public DateTime? ScheduledFor { get; set; }
    public DateTime? PublishedAt { get; set; }

    // Relacionamentos
    public Tenant Tenant { get; set; }
    public AppUser User { get; set; }
    public ICollection<Publication> Publications { get; set; }
}

public enum ContentType
{
    Text = 1,
    Image = 2,
    Video = 3,
    Link = 4
}

public enum ContentStatus
{
    Draft = 1,
    Scheduled = 2,
    Publishing = 3,
    Published = 4,
    Failed = 5
}
```

**Publication.cs**
```csharp
namespace InfluenciAI.Domain.Entities;

public class Publication : BaseEntity
{
    public Guid ContentId { get; set; }
    public Guid SocialProfileId { get; set; }
    public string ExternalId { get; set; } // ID do post na rede social
    public string ExternalUrl { get; set; } // URL do post
    public PublicationStatus Status { get; set; }
    public DateTime? PublishedAt { get; set; }
    public string ErrorMessage { get; set; }

    // Relacionamentos
    public Content Content { get; set; }
    public SocialProfile SocialProfile { get; set; }
    public ICollection<MetricSnapshot> Metrics { get; set; }
}

public enum PublicationStatus
{
    Pending = 1,
    Publishing = 2,
    Published = 3,
    Failed = 4
}
```

### 1.2 Application Layer - Commands & Queries

**ConnectSocialProfileCommand.cs**
```csharp
namespace InfluenciAI.Application.SocialProfiles.Commands;

public record ConnectSocialProfileCommand(
    SocialNetwork Network,
    string AccessToken,
    string RefreshToken,
    DateTime TokenExpiresAt
) : IRequest<SocialProfileDto>;

public class ConnectSocialProfileHandler : IRequestHandler<ConnectSocialProfileCommand, SocialProfileDto>
{
    private readonly AppDbContext _context;
    private readonly ITwitterService _twitterService;
    private readonly ICurrentUserService _currentUser;

    public async Task<SocialProfileDto> Handle(ConnectSocialProfileCommand request, CancellationToken ct)
    {
        // 1. Obter info do perfil da API do Twitter
        var twitterProfile = await _twitterService.GetUserProfileAsync(request.AccessToken);

        // 2. Verificar se já existe conexão
        var existing = await _context.SocialProfiles
            .FirstOrDefaultAsync(sp =>
                sp.Network == request.Network &&
                sp.ProfileId == twitterProfile.Id &&
                sp.TenantId == _currentUser.TenantId, ct);

        if (existing != null)
        {
            // Atualizar tokens
            existing.AccessToken = EncryptToken(request.AccessToken);
            existing.RefreshToken = EncryptToken(request.RefreshToken);
            existing.TokenExpiresAt = request.TokenExpiresAt;
            existing.IsActive = true;
        }
        else
        {
            // Criar nova conexão
            existing = new SocialProfile
            {
                TenantId = _currentUser.TenantId,
                UserId = _currentUser.UserId,
                Network = request.Network,
                ProfileId = twitterProfile.Id,
                Username = twitterProfile.Username,
                DisplayName = twitterProfile.Name,
                ProfileImageUrl = twitterProfile.ProfileImageUrl,
                AccessToken = EncryptToken(request.AccessToken),
                RefreshToken = EncryptToken(request.RefreshToken),
                TokenExpiresAt = request.TokenExpiresAt,
                IsActive = true,
                ConnectedAt = DateTime.UtcNow
            };
            _context.SocialProfiles.Add(existing);
        }

        await _context.SaveChangesAsync(ct);
        return MapToDto(existing);
    }
}
```

**PublishContentCommand.cs**
```csharp
namespace InfluenciAI.Application.Content.Commands;

public record PublishContentCommand(
    Guid ContentId,
    Guid SocialProfileId
) : IRequest<PublicationDto>;

public class PublishContentHandler : IRequestHandler<PublishContentCommand, PublicationDto>
{
    private readonly AppDbContext _context;
    private readonly ITwitterService _twitterService;

    public async Task<PublicationDto> Handle(PublishContentCommand request, CancellationToken ct)
    {
        // 1. Obter conteúdo e perfil
        var content = await _context.Contents.FindAsync(request.ContentId);
        var profile = await _context.SocialProfiles.FindAsync(request.SocialProfileId);

        if (content == null || profile == null)
            throw new NotFoundException();

        // 2. Criar registro de publicação
        var publication = new Publication
        {
            ContentId = content.Id,
            SocialProfileId = profile.Id,
            Status = PublicationStatus.Publishing
        };
        _context.Publications.Add(publication);
        await _context.SaveChangesAsync(ct);

        try
        {
            // 3. Publicar no Twitter
            var accessToken = DecryptToken(profile.AccessToken);
            var tweetResult = await _twitterService.PublishTweetAsync(accessToken, content.Body);

            // 4. Atualizar com sucesso
            publication.Status = PublicationStatus.Published;
            publication.ExternalId = tweetResult.Id;
            publication.ExternalUrl = tweetResult.Url;
            publication.PublishedAt = DateTime.UtcNow;

            content.Status = ContentStatus.Published;
            content.PublishedAt = DateTime.UtcNow;
        }
        catch (Exception ex)
        {
            // 5. Atualizar com erro
            publication.Status = PublicationStatus.Failed;
            publication.ErrorMessage = ex.Message;
            content.Status = ContentStatus.Failed;
        }

        await _context.SaveChangesAsync(ct);
        return MapToDto(publication);
    }
}
```

### 1.3 Infrastructure - Twitter Integration

**ITwitterService.cs**
```csharp
namespace InfluenciAI.Infrastructure.Integration.Twitter;

public interface ITwitterService
{
    Task<TwitterUserProfile> GetUserProfileAsync(string accessToken);
    Task<TweetResult> PublishTweetAsync(string accessToken, string text);
    Task<TweetMetrics> GetTweetMetricsAsync(string accessToken, string tweetId);
}

public record TwitterUserProfile(string Id, string Username, string Name, string ProfileImageUrl);
public record TweetResult(string Id, string Url);
public record TweetMetrics(int Views, int Likes, int Retweets, int Replies);
```

**TwitterService.cs (usando Tweetinvi)**
```csharp
using Tweetinvi;
using Tweetinvi.Models;

namespace InfluenciAI.Infrastructure.Integration.Twitter;

public class TwitterService : ITwitterService
{
    private readonly IConfiguration _config;

    public TwitterService(IConfiguration config)
    {
        _config = config;
    }

    public async Task<TwitterUserProfile> GetUserProfileAsync(string accessToken)
    {
        var client = new TwitterClient(accessToken);
        var user = await client.Users.GetAuthenticatedUserAsync();

        return new TwitterUserProfile(
            user.IdStr,
            user.ScreenName,
            user.Name,
            user.ProfileImageUrl
        );
    }

    public async Task<TweetResult> PublishTweetAsync(string accessToken, string text)
    {
        var client = new TwitterClient(accessToken);
        var tweet = await client.Tweets.PublishTweetAsync(text);

        return new TweetResult(
            tweet.IdStr,
            tweet.Url
        );
    }

    public async Task<TweetMetrics> GetTweetMetricsAsync(string accessToken, string tweetId)
    {
        var client = new TwitterClient(accessToken);
        var tweet = await client.Tweets.GetTweetAsync(long.Parse(tweetId));

        return new TweetMetrics(
            tweet.RetweetCount + tweet.QuoteCount, // views approximation
            tweet.FavoriteCount,
            tweet.RetweetCount,
            0 // replies não disponível diretamente
        );
    }
}
```

### 1.4 API - Endpoints

**Program.cs (adicionar endpoints)**
```csharp
// Social Profiles endpoints
app.MapPost("/api/social-profiles", async (ConnectSocialProfileCommand cmd, IMediator mediator)
    => Results.Ok(await mediator.Send(cmd)))
    .RequireAuthorization();

app.MapGet("/api/social-profiles", async (IMediator mediator, CancellationToken ct)
    => Results.Ok(await mediator.Send(new ListSocialProfilesQuery(), ct)))
    .RequireAuthorization();

// Content endpoints
app.MapPost("/api/content", async (CreateContentCommand cmd, IMediator mediator)
    => Results.Ok(await mediator.Send(cmd)))
    .RequireAuthorization();

app.MapGet("/api/content", async (IMediator mediator, CancellationToken ct)
    => Results.Ok(await mediator.Send(new ListContentQuery(), ct)))
    .RequireAuthorization();

app.MapPost("/api/content/{id:guid}/publish", async (Guid id, PublishContentRequest req, IMediator mediator)
    => Results.Ok(await mediator.Send(new PublishContentCommand(id, req.SocialProfileId))))
    .RequireAuthorization();

public record PublishContentRequest(Guid SocialProfileId);
```

### 1.5 Desktop - Views

**SocialConnectionView.xaml**
- Botão "Conectar Twitter"
- Lista de conexões ativas
- Status de conexão (ativo/inativo)

**ContentEditorView.xaml**
- TextBox para texto do tweet
- Contador de caracteres (280 max)
- Dropdown para selecionar perfil conectado
- Botão "Publicar"
- Status de publicação (sucesso/erro)

### 1.6 Migrations

```bash
dotnet ef migrations add AddSocialProfilesAndContent --project src/Infra/InfluenciAI.Infrastructure --startup-project src/Server/InfluenciAI.Api
dotnet ef database update --project src/Infra/InfluenciAI.Infrastructure --startup-project src/Server/InfluenciAI.Api
```

### 1.7 Pacotes NuGet Necessários

```xml
<!-- Infrastructure project -->
<PackageReference Include="TweetinviAPI" Version="5.0.4" />
```

---

## Sprint 3-4: Basic Analytics (2 semanas)

### Objetivos
- Coletar métricas de tweets publicados
- Armazenar em time series
- Exibir no Desktop em tempo real

### 2.1 Domain Layer - Métricas

**MetricSnapshot.cs**
```csharp
namespace InfluenciAI.Domain.Entities;

public class MetricSnapshot : BaseEntity
{
    public Guid PublicationId { get; set; }
    public DateTime CollectedAt { get; set; }
    public int Views { get; set; }
    public int Likes { get; set; }
    public int Retweets { get; set; }
    public int Replies { get; set; }
    public decimal EngagementRate { get; set; }

    // Relacionamento
    public Publication Publication { get; set; }
}
```

### 2.2 Background Service - Data Collector

**DataCollectorService.cs**
```csharp
namespace InfluenciAI.Infrastructure.Services;

public class DataCollectorService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<DataCollectorService> _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            using var scope = _serviceProvider.CreateScope();
            var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
            var twitterService = scope.ServiceProvider.GetRequiredService<ITwitterService>();

            // Buscar publicações recentes (últimas 24h)
            var recentPublications = await context.Publications
                .Include(p => p.SocialProfile)
                .Where(p => p.Status == PublicationStatus.Published &&
                           p.PublishedAt >= DateTime.UtcNow.AddHours(-24))
                .ToListAsync(stoppingToken);

            foreach (var publication in recentPublications)
            {
                try
                {
                    // Determinar frequência de coleta
                    var timeSincePublish = DateTime.UtcNow - publication.PublishedAt.Value;
                    var shouldCollect = timeSincePublish.TotalHours <= 2 ? true : // a cada 5 min
                                       timeSincePublish.TotalHours <= 24 ? DateTime.UtcNow.Minute % 60 == 0 : // a cada 1h
                                       false;

                    if (!shouldCollect) continue;

                    // Coletar métricas
                    var accessToken = DecryptToken(publication.SocialProfile.AccessToken);
                    var metrics = await twitterService.GetTweetMetricsAsync(accessToken, publication.ExternalId);

                    // Salvar snapshot
                    var snapshot = new MetricSnapshot
                    {
                        PublicationId = publication.Id,
                        CollectedAt = DateTime.UtcNow,
                        Views = metrics.Views,
                        Likes = metrics.Likes,
                        Retweets = metrics.Retweets,
                        Replies = metrics.Replies,
                        EngagementRate = CalculateEngagementRate(metrics)
                    };
                    context.MetricSnapshots.Add(snapshot);

                    // Cache no Redis para consulta rápida
                    await CacheMetricsAsync(publication.Id, snapshot);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error collecting metrics for publication {PublicationId}", publication.Id);
                }
            }

            await context.SaveChangesAsync(stoppingToken);

            // Aguardar 5 minutos
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}
```

### 2.3 API - Endpoint de Métricas

```csharp
app.MapGet("/api/content/{id:guid}/metrics", async (Guid id, IMediator mediator, CancellationToken ct)
    => Results.Ok(await mediator.Send(new GetContentMetricsQuery(id), ct)))
    .RequireAuthorization();

public record GetContentMetricsQuery(Guid ContentId) : IRequest<ContentMetricsDto>;

public record ContentMetricsDto(
    Guid ContentId,
    DateTime? PublishedAt,
    MetricSnapshotDto Latest,
    List<MetricSnapshotDto> Timeseries
);

public record MetricSnapshotDto(
    DateTime CollectedAt,
    int Views,
    int Likes,
    int Retweets,
    int Replies,
    decimal EngagementRate
);
```

### 2.4 Desktop - Metrics View

**MetricsView.xaml**
- Números principais (cards): Views, Likes, Retweets, Replies
- Gráfico de linha (LiveCharts2): Evolução ao longo do tempo
- Auto-refresh a cada 30 segundos

---

## Sprint 5-6: Polish & Stabilization (1-2 semanas)

### 3.1 Error Handling

**Retry Logic com Polly**
```csharp
services.AddHttpClient<ITwitterService, TwitterService>()
    .AddTransientHttpErrorPolicy(policy =>
        policy.WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))
    .AddTransientHttpErrorPolicy(policy =>
        policy.CircuitBreakerAsync(5, TimeSpan.FromMinutes(1)));
```

**Rate Limit Handling**
- Detectar 429 (Too Many Requests)
- Aguardar tempo especificado no header `Retry-After`
- Notificar usuário no Desktop

**Token Expiration**
- Detectar 401 (Unauthorized)
- Tentar refresh automático
- Se falhar, solicitar reconexão

### 3.2 Testes

**Integration Tests**
```csharp
public class TwitterIntegrationTests : IClassFixture<WebApplicationFactory<Program>>
{
    [Fact]
    public async Task ShouldPublishTweetSuccessfully()
    {
        // Arrange
        var client = _factory.CreateClient();
        var content = new { body = "Test tweet from InfluenciAI" };

        // Act
        var response = await client.PostAsJsonAsync("/api/content", content);
        var contentDto = await response.Content.ReadFromJsonAsync<ContentDto>();

        var publishResponse = await client.PostAsJsonAsync(
            $"/api/content/{contentDto.Id}/publish",
            new { socialProfileId = _testProfileId });

        // Assert
        publishResponse.EnsureSuccessStatusCode();
        var publication = await publishResponse.Content.ReadFromJsonAsync<PublicationDto>();
        Assert.NotNull(publication.ExternalId);
    }
}
```

### 3.3 Documentação

Criar `docs/InfluenciAI-Documentation/07-UserGuide/07.1-TwitterIntegration.md`:
- Como conectar conta do Twitter
- Como criar e publicar tweet
- Como visualizar métricas
- Troubleshooting (erros comuns)

---

## Critérios de Aceite (Definition of Done)

- [ ] Usuário consegue conectar conta do Twitter via Desktop
- [ ] Sistema armazena tokens de forma segura (encrypted)
- [ ] Usuário consegue criar tweet de até 280 caracteres
- [ ] Validação impede publicação com mais de 280 chars
- [ ] Publicação no Twitter funciona e retorna ID do tweet
- [ ] Métricas são coletadas automaticamente a cada 5 min (primeiras 2h)
- [ ] Desktop exibe métricas atualizadas em tempo real
- [ ] Gráfico mostra evolução das métricas ao longo do tempo
- [ ] Sistema trata rate limit do Twitter gracefully
- [ ] Sistema trata token expirado e solicita reconexão
- [ ] Testes end-to-end cobrem fluxo completo (happy path)
- [ ] Testes cobrem cenários de erro (rate limit, token expirado, network error)
- [ ] Documentação de uso está completa
- [ ] Code review realizado e aprovado

---

## Riscos e Mitigações

| Risco | Probabilidade | Impacto | Mitigação |
|-------|---------------|---------|-----------|
| Twitter API muda (v2 → v3) | Baixa | Alto | Camada de abstração (ITwitterService) |
| Rate limit em dev | Média | Médio | Usar Twitter Developer Plan elevado |
| OAuth flow complexo | Baixa | Alto | Usar biblioteca Tweetinvi pronta |
| Tokens expiram durante desenvolvimento | Alta | Baixo | Implementar auto-refresh desde o início |
| Coleta de métricas cara (muitas chamadas API) | Média | Médio | Ajustar frequência dinamicamente, cache Redis |

---

## Métricas de Sucesso do MVP

**Métricas Técnicas:**
- ✅ Tempo de resposta < 2s para publicação
- ✅ Uptime do DataCollectorService > 99%
- ✅ Cobertura de testes > 80%

**Métricas de Produto:**
- ✅ Usuário consegue publicar primeiro tweet em < 2 minutos
- ✅ Métricas aparecem no Desktop em < 5 minutos após publicação
- ✅ Taxa de erro de publicação < 1%

**Validação de Valor:**
- ✅ Pelo menos 5 usuários beta publicam tweets via plataforma
- ✅ Feedback positivo sobre facilidade de uso
- ✅ Usuários conseguem interpretar métricas sem ajuda

---

## Próximos Passos Após MVP

Após conclusão deste MVP, priorizar:

1. **Agendamento de Posts** (Sprint 7-8)
   - Permitir agendar tweet para data/hora futura
   - Background job para publicar no horário agendado

2. **Múltiplas Contas Twitter** (Sprint 9)
   - Permitir conectar várias contas do mesmo usuário
   - Publicar mesmo tweet em múltiplas contas simultaneamente

3. **Segunda Rede Social** (Sprint 10-12)
   - Integração com Instagram (Business API)
   - Adapter pattern para abstrair diferenças entre redes

4. **IA para Otimização** (Sprint 13-16)
   - Sugerir melhor horário para publicar
   - Prever engagement esperado
